# 싱글 스레드로 서버를 만들 수 있을까?

## 목차
1. 왜 파이썬?
2. 왜 asyncio
3. 모두 async 하게
4. 더 필요한 건 만들자
5. 실제로 써보니

## 도입
상황 : 노 베이스 + 8개월 기한 + 높은 완성도  
이상 : 노 빌드 + 무중단 패치 + 고른 코딩 품질 + 칼퇴근  
-> python을 씀

## 1. 왜 파이썬?
시간이 없음  
쉬운 언어  
라이브러리와 참고자료가 많음  
범용적임 : 서버도 되고 툴도 되고 웹도 되고 멀티 플랫폼에 AWS친화적

### 게임 서버 구현 목표
I/O intensive  
수평 확장(게임 서버와 DB) 고려  
서버 성능 보다는 확장성

## 2. 왜 asyncio?
싱글 스레드로 병행 처리가능 -> event loop덕분, 콜백 대신 코루틴을 사용함

### 콜백
callback hell
```
{
  {
    {
      {
        {
          이런거
        }
      }
    }
  }
}
```
요즘엔 개선됨

### 코루틴
콜백없이 이벤트 루프 사용 가능  
슬라이드 오른쪽에 실행 순서는 나중에 발표자료 보고 참고할 것  
```python
async def getData(d):
  c = await getMoreData(d)
  b = await getMoreMoreData(c)
  a = await getMoreMoreMoreData(b)
  return a
```
왜 이렇게 말이 빠르담 ㅠㅠ

### 좋은 점
1 프로세스, 1 스레드  
스레드 하나로 완전한 서버로 만들 수 있다.  
코어 수 만큼 서버 프로세스를 생성하여 멀티 프로세스 서버 구동  
- 서버 프로세스 독립적
- 확장 쉽고 관리가 편함
- 하나가 죽어도 서비스 유지 가능
- GIL에서 자유로움

### 성능
좋음  
사진이 조그매서 안보이네  
aiohttp가 가장 좋다는 얘기

### 기존의 비동기, 코루틴 기반 병행 처리 라이브러리
- enventlet
- gevent : 얘도 게임서버로 많이 쓰임, 파이썬 3이 아니었다면 얘를 썼을 듯
- tornado
- twisted

### 그럼에도
asyncio는 표준 라이브러리!  
3.5버전 이후로 `async`/`await` 문법이 추가됨

## 모든 것을 async 하게
조심해야 하는게 block이 있으면 전체 이벤트루프가 정지  
대표적인 blocking 포인트  
- 네트워크
- 디비
- 게임로직

### 네트워크
모바일 게임 서버 : 접속이 불안정, 신속한 응답이 필요없을 때가 있음  
웹 서버가 적합한 경우가 많음 -> aiohttp를 사용하자  
`handle_clear_dungeon()` 이 콜백  
데코레이터를 사용하여 핸들러를 등록

**TCP 서버**도 존재  
- 연결을 계속 유지하기 위해 : 채팅
- 유저간 상호작용을 위해 : PVP, 파티 던전  
  asyncio에서 tcp서버 충분히 구현 가능  
  서버간 통신은 Redis의 pub/sub사용

### DB
DynamoDB : 메인DB로 사용, 비용은 좀 고려해야함  
AWS 제품을 위한 **BOTO** 라이브러리  
**하지만** block이 일어남 : `get_item()`함수에서 DB가 응답할 때까지 block  
-> 개조를 해서 해결함 : DynamoDBConnection 오버라이드

Redis : asyncio용 redis라이브러리 존재  
Redis + Hashring : 무슨소린지 잘 모르겠네  
-> 클래스 하나 만들고 중복된 부분을 `__getattr__`에서 `wrapper`로 감싸줌  
Redis 캐시 : k-v storage, 여기도 중복 부분을 데코레이터로 연동

MySQL : 로그, 통계용도로 많이 호출됨 -> asyncio용 mysql라이브러리 존재

### 게임 로직
유저 로그인, 아이템 구매, 던전 클리어 같은 코드  
한번의 요청 -> 여러 번 DB/캐시, 웹 API  
asyncio의 혜택을 가장 많이 받음

기존 방식 : DB스레드와 로직스레드를 왔다갔다, 핸들러 만드는건 덤

## 더 필요한 건 만들자
### Handler Unique ID
패킷 하나를 처리하는 동안의 db로그에 같은 id를 갖게 해주세요  
-> 쉬움, log함수에 인자 하나만 추가하면 됨.   
-> 근데 모든 소스 코드에 해야함  
-> 그래서 핸들러 실행 전 함수를 추가하고 로그 함수 내부에 **inspect모듈**로 콜스택을 추적하고 핸들러 실행 전에 실행되는 함수의 uuid를 인자로 갖고옴

### Distribute Lock
어떤 리소스에 Lock을 걸어야 하는 일이 생김  
-> 이게 다 아이템 복제 때문  
-> 이게 다 NoSQL이기 때문  
-> Redis를 건드림 : 예외 처리 구문을 추가하고 `with` state 사용, with종료 전에 다른 곳에서 with들어오면 에러 발생하게끔

### 콜백을 awaitable 하게
Future객체를 만들고  
사진을 못찍었네 **코드 중요함 한번 찾아볼 것**

## 실제로 써보니
서비스 중 몇 건의 이슈 : 모두 DB, 미들웨어와 관련된 이슈  
서버 이슈는 1건 : 버그로 인한 무한 Task 생성 -> 그래도 서버의 전체 서비스에는 문제가 없었음

### 아쉬운 점
- 로그 분석 준비 부족 : 뒤늦게 **logbook**존재를 알게 됨
- 전부 웹 서버로 서비스 할 수 있음 : 양방향 통신 가능, long polling, server sent events, web socket
- uv_loop를 적용하지 못했음

### 유의사항
- async 키워드 생략 : **예제 코드 실행해보기 **, 에러도 안생기고 리턴 값이 None도 아님  
  코드에 `event_loop_set_debug(True)` 추가
- slow function : 어떤 함수가 느린지 찾기 힘듬, 얘도 아까랑 마찬가지로 해결
- 프로파일러 : 메무리 누수를 찾기 위한 삽질, 결과가 도움이 안됐음  
  -> 왓스튜디오의 **profiling** 이 asyncio 지원

## 지금은
라이브러리가 풍부해짐
- sanic
- uv_loop : python 3.6을 쓴다면 붙여보면 좋을 것
- aio_http 2.0 : 웹서버 라이브러리에서 완성도가 높음
- pypy : JIT컴파일러, 코드수정없이 속도를 많이 끌어올릴 수 있음, 파이썬 3.5버전까지 지원
- FAT Python : 최적화된 파이썬 코드 생성

## 결론
추천추천  
i/o bound작업이 많을때  
서로 독립적인 task가 많을때 

## QNA
1대 서버 80개 프로세스에 6만 동접  
동기화가 필요하다면 기존 C++서버같이 게임루프 돌면서 상대방 신호가 올때까지 계속 대기하는 로직을 사용  
UDP도 지원함  
요즘엔 웹 서버가 클라이언트한테도 send할 수 있기 때문에 TCP를 빼고싶다고 말한거임