# 내가 만든 언어로 게임 만들기
잦은 인터럽트 -> 연속된 시간 확보 어려움
외부 툴 가져다 쓰고, 기획자들이 최대한 스스로 할 수 있게
코드게 근접한 수준의 표현력, 직관성을 위한자유도 제한 -> 도메인 언어

## 도메인 언어
특정 문제를 풀기 위해 만들어진 언어
- html 웹페이지 
- json 데이터 오브젝트를 텍스트로 전달
- 정규표현식 패턴 매칭
  즉, 문제에 집중하자

## 발표 내용
게임 캐릭터를 만드는 것
도메인 1 : 행동 제어
도메인 2 : 상호작용과 연산
FSM을 이용한 핸동 결정, 전투연산 해봤으면 강연 이해가 쉬움
언어를 만드는 이유, 사례로 보는 설계, 구현, 활용 예시, 비용과 효과, 어려움과 대응

## 언어 1 - FSM언어
행동 결정을 위해서는 FSM을 만들어야 함
FSM : 여러 스테이트 사이를 오가는 조건을 정의
처음에는 비쥬얼 스크립팅을 고려 -> 변경사항 추적이 어려움, 갈수록 복잡도가 증가, 커스터마이징 어려움
발표자의 목표 : 비주얼 스크립팅을 쓰고싶지만 편집 환경이 텍스트 였으면

### 언어 설계
[정지]
방향키누름 -> [이동]
공격당함 -> [피격]
에서 이벤트로 처리할 수 있는건 (), 지속적인 관측을 해야하면 그냥 두고
state에 들어올 때 : 진입 이벤트 : @를 붙임

[죽음]
@들어올때 -> "Die" -> 모션전환 -> "4" -> 기다리기 -> 객체소멸

지금까지 나온 문법 정리 -> 사진으로 찍음

### 연결
FSM Script, C# 객체(실제 함수 구현) -> FSM
심볼들은 C#의 객체함수와 매핑해야함
모션전환 := ChangeMotion같은 식으로

### 구현전략
FSM을 만들 거임, 모든 심볼은 C# 함수와 1:1 맵핑
1. 리플렉션을 이용한 **인터프리터**
2. C# 코드를 생성하는 **컴파일러**
   발표자는 인터프리터를 선택함 : 성능 오규치 낮음, 런타임 핫패치, 스크립트 패치 편의를 위해
   대신 스크립트 오류를 최대한 일찍 체크해야함
   특히 화살표의 와이어링 체크

#### 컨벤션
접미사를 붙인 이벤트 `피격모션끝`처럼
문법은 아니지만 컨벤션
한국어 스크립트

### 활용
FSM이 들어가면 다 활용할 수 있음
캐릭터, 몬스터, 필드 오브젝트, 3-Match퍼즐, 스테이지 자동 생성툴
HUD, UI, 메뉴트리
컷씬, 스테이지 연출 : 보통 코루틴으로 처리하는데 FSM을 활용하니 좋았음

즉, 스테이트 있는 로직, 이벤트 처리, 코루틴 대체
FSM이 있다고 가정하고 로직, 연출 작성용 **기본 도구**로 인식

### 언어 확장
많이 쓰는 FSM을 보면 스테이트 상속을 쓰기도 하는데
발표자는 **Stacked FSM**을 구현함 : 돌아가기 기능을 위해
돌아가기 구현 -> 상위 메뉴로 가기, 캐릭터 이전 상태로 가기
꺽쇠괄호를 활용해 push, pop구현
3번 선택해서 들어갔으면 나왔을때도 3번이고 싶다 -> State scope variable : 스테이트 안에 변수가 생김

변수를 넣으니 다르게 활용하는 방식이 생김

### 비용
너무 빨리 지나갔음 ㅡㅡ

### 정리
이거두 너무 빨리 지나감

### 후기
기획자가 알아서 고치기 시작함

FSM을 만들어 줬으니 캐릭터를 만들 수 있나? -> 이걸 위해 언어 2

## 언어 2 - 액션 패턴

### 왜 만들었을까
수치 연산 코딩 피하기 -> 조립하듯 원하는걸 만들기
표준모델 -> 연산유닛, 표현식 -> 액션패턴

### 연산유닛
기획자의 의도를 표현할 수 있어야 함
게이지, 스탯, 상태효과 이 3가지면 다 커버할 수 있지 않을까?
상태효과 -> 스탯 변경(장비 아이템, 패시브, 기절), 점진적 영향(DOT데미지, 지연 회복)으로 구분

#### 설계 : 게이지
초기화 Init("HP", 0, 100, 100)
변경 Modify("HP", -20) 같은 형태

#### 설계 : 스탯
빨리 지나감

#### 설계 : 상태효과
공통 : 시간 처리, 이펙트, 중첩 여부

이걸 다 조립하면 연산유닛
연산유닛만으로 상호작용이 될까? -> 결론적으로 안됨
값변경이 아니라 **행위**를 통해 상호작용해야함

### 액션패턴
다른 캐릭터에게 할 수 있는 **행위**를 기술
1. 누구에게 : 타겟 파인더(히트박스)
2. 무엇을 : 액션 타입(상수)
3. 얼마나 : 인자(숫자, 수식)

- 액션 보낼 때
  타겟 파인터(self, 근접, 전방3m...) -> 액션 타입 -> 인자 -> 액션 전송
- 액션 받을 때
  액션확인(정의된 액션인지) -> 액션 받을지(면역, 회피, 상태이상, 중첩불가) -> 적용수치 -> 변경적용

### 연결
액션 패턴 전달을 누가 해주는 거야
1. 애니메이션 키에 삽입 : 특정 프레임에 이벤트로 날림
2. 트리거, 충돌 이벤트
3. 사용자 입력

### 응용 : 분기
연출을 어떻게 할까요

연산 유닛의 실행 과정 : 성공 여부를 확인 -> 실행 지속 여부 결정(short circuit evaluation)
if문 쓸 때 and 연쇄 : 실패하면 중지
or 연쇄 : 성공하면 중지

### 응용 : 이펙트
게임 연산은 아니지만 타이밍, 이펙트 종류 설정하기 편함
SFX, VFX(타겟, 리소스id)

### 응용 : 탄체
원거리 물리 공격은 탄체 발사로 처리
탄체 안에는 안에 연산 유닛이 들어있다
발사자의 스탯을 일부 복제, 화살이 적을 죽이면 화살의 킬이 올라가는게 아니라 발사자의 킬을 올려주는 등 별도 처리 필요

### 비용
Action, Attach, Detach 2주
나머지는 그때 그때

### 정리
캐릭터 상호작용, 연산 구현 용도
기획 바뀔 때마다 코드 안 고치려고 만듬
연산 유닛은 시트로 초기화 할 수 있음
FSM에 붙여 쓰기 쉬움
탄체를 싸게 만듬

## 만들고 보니
### 기획자가 볼때
기획자에게는 어려움
대응 : 기획자에게 익숙한 방향 : 엑셀시트, 액션패턴을 작성해주고 활용
처음에는 **신뢰**를 쌓고 시스템 구조에 대한 이해를 증진
대화를 할 때 말이 통하고, 액션패턴으로 구현요청서를 설명해주기 시작

### 생산성
크런치 기간에 안바빴음
인터럽트 빈도가 낮아짐
게임이 뒤집어져도 코어 시스템 구현은 바뀌지 않음

### 언어를 설계할 때
하드코딩을 해서라도 규칙에서 벗어난 기능 구현해야함
이후에 시스템에 흡수하도록 노력해야함
기획은 언제나 별할 수 있음

실용주의 프로그래머 12절 <도메인 언어>

### IDE 지원
EditPlus, vim : 구문 강조는 쉽게 만들 수 있음
직접 구현 : 비용이 매우 비쌈
그래서 관련 이야기는 다음 세션에서 얘기함

## QNA
파서는 손으로 직접 짰음 -> 생각보다 어렵지 않음
내 실력과 타협해서 언어를 디자인하게 됨