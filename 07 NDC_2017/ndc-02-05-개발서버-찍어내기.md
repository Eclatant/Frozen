**Kubernetes**로 개발서버 간단히 찍어내기

## 데브시스터즈 서버팀
- 모두가 DevOps Engineer
  - 서버 구조 설계, 언어, 스택 선택, 프로토콜 구조
  - 기획 참여, 로직에 맞는 서버 코드
  - 배포, 모니터링, 장애 대응
  - 로그 조회 시스템
    할 일이 많고 다양하다
    최대한 노가다성 작업을 깔끔하게 만들고 자동화 시키자
    지금 설명드리는건 **쿠키런 : 오븐브레이크**에 적용이 되어있음

## 1. 문제 제기
왜 개발 서버를 "찍어내는 것"이 필요했나
### 새 서버가 유저를 만날 때까지
개발자가 로컬에서 구현을 마치면
-> DEV서버에 올라감 : 개발 서버 환경 -> 오늘 얘기할 대상
-> QA서버 : 검수, 테스트
-> STAGE서버 : 프로덕션과 유사, 마지막 테스트
-> PROD서버 : 실제 유저들이 접속하는 서버

### Dev 서버 하나를 모두가 같이 쓸 수 있을까?
처음엔 DEV서버가 하나였음
-> 로그인 연동 팀에서 뭔갈 바꿨는데 호환이 안됨
-> UX 개선 팀에서 크래스가 남
-> 내가 잘못했나? 하는 시간소비 이슈

- 밸런스 데이터를 바꿔야 하는데 다른 곳에 영향을 주기 싫어요
- 이벤트 QA 하려는데 서버 시간을 미래로 바꿔봐도 될까요
- 번역 작업을 하고 싶은데 테스트용 클라이언트를 다시 다운받기 싫음

-> DEV서버가 하나만 있으면 매우 불편

그럼 두 대를 쓰자!
-> 세 대를 쓰자! -> 네 대를 쓰자! 하다가 다른 해결책을 생각

## 2. 구현
- 원하는 시점에 원하는 버전
- 서버의 메타 정보 표시

띄울게 많고 서버간 통신도 필요하고 복잡하다
-> 때마침 Dockerize 가능했음
-> Container Orchestration Tool 을 사용하자 : **멀티 노드 도커**
뿐만 아니라 **스케쥴링** : 최적의 머신에 띄우기(e.g. 메모리가 많이 남는 서버)
**스케일링** : 도커 컨테이너를 여러머신에 여러대 띄우기 + 죽으면 살리기
**로드밸런싱** : 알아서 분산해줌

Container Orchestration Tool 고르기
-> 당시에 Amazon ECS, Docker(Swarm mode), Kubernetes
-> ECS가 좀 구렸음
-> 스웜모드는 심플하지만 기능 부족
-> 그래서 **Kubernetes**선택

### Kubernetes
구글 내부에서 쓰던 Borg의 오픈 소스 버젼
웹 UI 좀 괜찮음
**Pod** - 최소 단위 (docker container와 비슷)
Replica Set - Pod Scaler
Service - 로드밸런싱, 
-> Service Discovery : e.g. `curl http://nginx-svc:web-port` = `curl http://10.x.x.130:80`
Namespace - 리소스의 논리적 분리 단위
-> 요청을 보내는 도커의 namespace가 ns1이 아니라면 `nginx-svc.ns1:web-port`로 지정해줘야함

### Kubernetes 적용하기
각 서버 애플리케이션들은 모두 Kubernetes로
서버 환경별 namespace 생성
Logging Infra도 EC2 12개에 각각 띄워주는게 아니라 Kubernetes 안에 하나만 띄워도 됐음

이후부터 전문적인 내용이라 내용이 흘러간다 흘러가 \~

## 3. 리뷰
1. 개발팀 누구나 필요할 때 서버를 띄울 수 있게 -> 달성
2. 개발 서버 환경 운영 비용의 감소
3. 아쉬운점 : 복잡한 셋업 과정, 복잡한 문서, 잦은 API 버전 변경


